#!/bin/bash

# ------------------------------------------------------------
# General variables
MYNAME=$(basename $0)
TMP_FILE=/tmp/$(basename $0).$$
DATEFORMAT="+%d.%m.%Y-%H:%M:%S"

# Backup variables
BACKUP_DIR="/var/samba/daten/backup"
TIMESTAMP_FILE="$BACKUP_DIR/TIMESTAMP.txt"
README_FILE="$BACKUP_DIR/README.txt"
FILESYSTEMS_FILE="$BACKUP_DIR/FILESYSTEMS.txt"
EXCLUSIONS_FILE="$BACKUP_DIR/EXCLUSIONS.txt"
DISKUSAGE_FILE="$BACKUP_DIR/DISKUSAGE.txt"
LOG_FILE="$BACKUP_DIR/LOG.txt"
# ----- !!!!! File systems and exclusions are listed further down !!!!! -----

# ------------------------------------------------------------
# Check privileges
if test $(id -u) -ne 0; then
  echo "$MYNAME: Must be run with effective user ID 0"
  exit 1
fi

# ------------------------------------------------------------
# Print out what this program does, then ask for confirmation
# to continue
cat << EOF

This program is going to make a system backup. It will place
the backup files into this directory:

   $BACKUP_DIR

If the directory exists, its entire content will be overwritten.
If the directory does not exist, it will be created. After this
program terminates, you will usually copy the content of the
backup directory to some safe place, e.g. burn it to one or
more DVDs.

The backup is done using a combination of the find and cpio
programs. cpio is used in preference to tar because it can process
special files, and because my traditional mind remembers from the
times when I started to learn Unix, that cpio has generally less
restrictions than tar, especially when it comes to the maximum
length of path names. On reading the docs for GNU tar at
http://www.gnu.org/software/tar/manual/ it appears, though, as if
I am mistaken in this respect.

Press <ENTER> if you want me to go on and do the backup.
Otherwise hit Ctrl+C to abort.
EOF

read

# ------------------------------------------------------------
# Check if backup directory exists
if test -d "$BACKUP_DIR"; then
   echo "Backup directory $BACKUP_DIR already exists."
   read -p "Proceed and overwrite directory contents (y/n) " REPLY
   case "$REPLY" in
     [yY]) ;;
     *) exit 0;;
   esac

   rm -rf "$BACKUP_DIR"
   if test $? -ne 0; then
     echo "$MYNAME: Error removing backup directory $BACKUP_DIR"
     exit 1
   fi
fi

# ------------------------------------------------------------
# Create backup directory
mkdir -p "$BACKUP_DIR"
if test $? -ne 0; then
  echo "$MYNAME: Error creating backup directory $BACKUP_DIR"
  exit 1
fi

# ------------------------------------------------------------
# Write the README file
cat << EOF >"$README_FILE"
$(date "$DATEFORMAT")

This file and the content of its parent directory have been generated by
the system backup script

  $MYNAME

This script needs to be run manually. The automated nightly backup which
is run by cron stores its files elsewhere. See HerzbubeWiki for details.


Files with special meanings:
- $(basename "$FILESYSTEMS_FILE")
  Lists file systems that have been backed up.
- $(basename "$EXCLUSIONS_FILE")
  Lists directories and/or files that have been excluded from the system backup.
- $(basename "$DISKUSAGE_FILE")
  Lists the estimated disk usage of each file system that has been backed up.
  Exclusions are part of the estimate, it would have been too complicated to
  write code that takes exclusions into account.
- $(basename "$TIMESTAMP_FILE")
  Contains a timestamp when the system backup was launched.
- $(basename "$LOG_FILE")
  A log of the system backup procedure.
- $(basename "$README_FILE")
  This file.
- $MYNAME
  A copy of the system backup script. The purpose of this is to reflect the
  state of the script at the time when the backup was made.
EOF

# ------------------------------------------------------------
# Make a copy of this script
cp "$0" "$BACKUP_DIR/$MYNAME"

# ------------------------------------------------------------
# Write file systems to be included in the system backup to a file
cat << EOF >"$FILESYSTEMS_FILE"
/
/usr
/home
/var
/var/www
/var/cache
EOF

# ------------------------------------------------------------
# Write exclusions that should not be backed up to a file
# that grep can parse
# Note: the exclusion list should be as specific as possible
# so that only expected files and directories are excluded from
# backup. This means
# - start from the beginning of the path "./"
# - to exclude the directory itself, it must appear bounded
#   with a "$"
# - to prevent directories whose names have the same beginning
#   from also being excluded, a directory must appear with a
#   trailing "/"; example: /var/backups/* should be excluded,
#   but /var/backups/* should not.
cat << EOF >"$EXCLUSIONS_FILE"
^\\./home/[^/]*/exclude/
^\\./home/[^/]*/exclude\$
^\\./proc/
^\\./proc\$
^\\./sys/
^\\./sys\$
^\\./tmp/
^\\./tmp\$
^\\./var/backups/
^\\./var/backups\$
^\\./var/samba/
^\\./var/samba\$
EOF

# ------------------------------------------------------------
# Initialize disk usage file
rm -f "$DISKUSAGE_FILE"
echo -e "Overall file system statistics (generated by df -h)\n" >>"$DISKUSAGE_FILE"
df -h >>"$DISKUSAGE_FILE"

# ------------------------------------------------------------
# Iterate file systems and make one backup file per file system
cd /
echo ""
echo "$(date "$DATEFORMAT")" >"$TIMESTAMP_FILE"
(
for FILESYSTEM in $(cat "$FILESYSTEMS_FILE")
do
  # ---------- Step ----------
  echo -e  "\nBacking up file system $FILESYSTEM"
  BACKUP_FILE="$BACKUP_DIR/$(echo $FILESYSTEM | awk '{gsub(/^\//, "", $0); gsub(/\//, ".", $0); if (length($0) == 0) {print "root"} else {print $0}}').cpio"
  BACKUP_CONTENTFILE="$BACKUP_FILE.content.txt"
  # ---------- Step ----------
  echo "  $(date "$DATEFORMAT")  Generating disk usage..."
  echo -e "\nDisk usage for file system $FILESYSTEM (generated by du -shx)\n" >>"$DISKUSAGE_FILE"
  cd "$FILESYSTEM"
  du -shx * >>"$DISKUSAGE_FILE" 2>&1
  cd - >/dev/null
  # ---------- Step ----------
  echo "  $(date "$DATEFORMAT")  Creating file list..."
  # Important: Start with "." to make the path name relative
  find ".$FILESYSTEM" -depth -mount -print | grep -vf "$EXCLUSIONS_FILE"  >"$BACKUP_CONTENTFILE"
  if test $? -ne 0; then
    echo "  $(date "$DATEFORMAT")  Error writing content file $BACKUP_CONTENTFILE; leaving the file for your inspection..."
    continue
  fi
  # ---------- Step ----------
  NR_OF_FILES=$(wc -l "$BACKUP_CONTENTFILE" | awk '{print $1}')
  echo "  $(date "$DATEFORMAT")  Creating archive..."
  # Redirecting stderr to suppress message printed by cpio when
  # it is finished (e.g. "126091 blocks")
  cat "$BACKUP_CONTENTFILE" | cpio -o >"$BACKUP_FILE" 2>/dev/null
  if test $? -ne 0; then
    echo "$(date "$DATEFORMAT")  Error writing archive file $BACKUP_FILE; leaving the file for your inspection..."
    continue
  fi
  FULL_SIZE=$(ls -lh "$BACKUP_FILE" | awk '{print $5}')
  # ---------- Step ----------
  echo "  $(date "$DATEFORMAT")  Compressing archive..."
  gzip "$BACKUP_FILE"
  if test $? -ne 0; then
    echo "$(date "$DATEFORMAT")  Error compressing archive file $BACKUP_FILE; leaving the file for your inspection..."
    continue
  fi
  COMPRESSED_SIZE=$(ls -lh "$BACKUP_FILE.gz" | awk '{print $5}')
  # ---------- Step ----------
  echo "  $(date "$DATEFORMAT")  Backup complete: $NR_OF_FILES files, using $FULL_SIZE/$COMPRESSED_SIZE of uncompressed/compressed space..."
done
) 2>&1 | tee "$LOG_FILE"

# ------------------------------------------------------------
# Cleanup
rm -f $TMP_FILE
